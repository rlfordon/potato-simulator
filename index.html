<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ü•î Potato Simulator</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Lilita+One&family=Quicksand:wght@500;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #2d1a0e;
    font-family: 'Quicksand', sans-serif;
    overflow: hidden;
    height: 100vh;
    user-select: none;
    -webkit-user-select: none;
  }

  canvas { display: block; }

  #ui-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 10;
  }

  #hud {
    position: absolute;
    top: 15px; left: 15px; right: 15px;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    pointer-events: none;
  }

  .hud-box {
    background: rgba(0,0,0,0.6);
    border: 3px solid #f4a020;
    border-radius: 15px;
    padding: 10px 18px;
    color: #fff;
    font-family: 'Lilita One', cursive;
    font-size: 18px;
    text-shadow: 2px 2px 0 rgba(0,0,0,0.5);
  }

  .health-bar-container {
    width: 200px;
    height: 22px;
    background: #333;
    border-radius: 11px;
    overflow: hidden;
    border: 2px solid #f4a020;
    margin-top: 5px;
  }

  .health-bar {
    height: 100%;
    background: linear-gradient(to right, #ff4444, #ff8844, #44cc44);
    border-radius: 11px;
    transition: width 0.3s;
  }

  .ally-icons {
    display: flex;
    gap: 5px;
    margin-top: 5px;
  }

  .ally-icon {
    font-size: 22px;
    filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.5));
  }

  /* Screens */
  .screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    pointer-events: auto;
    z-index: 20;
  }

  #title-screen {
    background: radial-gradient(ellipse at center, #5a3a1a 0%, #2d1a0e 70%);
  }

  .title-potato {
    font-size: 120px;
    animation: bounce 1.5s ease-in-out infinite;
    filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5));
  }

  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-20px); }
  }

  .game-title {
    font-family: 'Lilita One', cursive;
    font-size: clamp(36px, 8vw, 72px);
    color: #f4a020;
    text-shadow: 4px 4px 0 #8b4513, 6px 6px 0 rgba(0,0,0,0.3);
    margin: 10px 0;
    text-align: center;
  }

  .subtitle {
    font-family: 'Quicksand', sans-serif;
    font-size: clamp(14px, 3vw, 22px);
    color: #ddb87a;
    margin-bottom: 30px;
    text-align: center;
    padding: 0 20px;
  }

  .btn {
    font-family: 'Lilita One', cursive;
    font-size: 28px;
    padding: 15px 50px;
    border: 4px solid #f4a020;
    border-radius: 50px;
    background: linear-gradient(to bottom, #e88a10, #c06a00);
    color: #fff;
    cursor: pointer;
    text-shadow: 2px 2px 0 rgba(0,0,0,0.3);
    box-shadow: 0 6px 0 #8b4513, 0 8px 15px rgba(0,0,0,0.4);
    transition: all 0.1s;
    pointer-events: auto;
  }

  .btn:hover { transform: translateY(2px); box-shadow: 0 4px 0 #8b4513, 0 6px 10px rgba(0,0,0,0.4); }
  .btn:active { transform: translateY(4px); box-shadow: 0 2px 0 #8b4513; }

  #level-screen {
    background: rgba(0,0,0,0.85);
    display: none;
  }

  .level-title {
    font-family: 'Lilita One', cursive;
    font-size: clamp(28px, 6vw, 52px);
    color: #f4a020;
    text-shadow: 3px 3px 0 #8b4513;
  }

  .level-desc {
    color: #ddb87a;
    font-size: clamp(14px, 3vw, 20px);
    margin: 15px 0 30px;
    text-align: center;
    padding: 0 20px;
    max-width: 500px;
  }

  .enemy-preview {
    font-size: 50px;
    margin: 10px 0 20px;
    display: flex;
    gap: 15px;
  }

  #game-over-screen, #win-screen {
    background: rgba(0,0,0,0.85);
    display: none;
  }

  .big-emoji { font-size: 80px; margin-bottom: 15px; }

  .score-text {
    font-family: 'Lilita One', cursive;
    font-size: 24px;
    color: #ddb87a;
    margin: 10px 0 25px;
  }

  /* Mobile controls */
  #mobile-controls {
    position: absolute;
    bottom: 15px;
    left: 0; right: 0;
    display: none;
    justify-content: space-between;
    padding: 0 15px;
    pointer-events: auto;
    z-index: 15;
  }

  .dpad {
    display: grid;
    grid-template-columns: 55px 55px 55px;
    grid-template-rows: 55px 55px 55px;
    gap: 3px;
  }

  .dpad-btn {
    background: rgba(255,255,255,0.2);
    border: 2px solid rgba(255,255,255,0.4);
    border-radius: 12px;
    color: white;
    font-size: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
  }

  .dpad-btn:active { background: rgba(255,255,255,0.4); }

  .action-buttons {
    display: flex;
    gap: 10px;
    align-items: flex-end;
  }

  .action-btn {
    width: 70px; height: 70px;
    border-radius: 50%;
    border: 3px solid;
    font-family: 'Lilita One', cursive;
    font-size: 13px;
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    -webkit-tap-highlight-color: transparent;
  }

  .attack-btn { background: rgba(255,60,60,0.5); border-color: #ff4444; }
  .recruit-btn { background: rgba(60,180,60,0.5); border-color: #44bb44; }

  @media (pointer: coarse) {
    #mobile-controls { display: flex; }
  }

  .damage-flash {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(255,0,0,0.3);
    pointer-events: none;
    z-index: 5;
    animation: flashOut 0.3s forwards;
  }

  @keyframes flashOut {
    to { opacity: 0; }
  }

  .floating-text {
    position: absolute;
    font-family: 'Lilita One', cursive;
    font-size: 24px;
    pointer-events: none;
    z-index: 25;
    animation: floatUp 1s forwards;
  }

  @keyframes floatUp {
    0% { opacity: 1; transform: translateY(0); }
    100% { opacity: 0; transform: translateY(-60px); }
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="ui-overlay">
  <div id="hud" style="display:none;">
    <div class="hud-box">
      <div>ü•î Spud HP</div>
      <div class="health-bar-container">
        <div class="health-bar" id="health-bar" style="width:100%"></div>
      </div>
    </div>
    <div class="hud-box" id="level-display">Level 1</div>
    <div class="hud-box">
      <div>Enemies: <span id="enemy-count">0</span></div>
      <div>Score: <span id="score-display">0</span></div>
      <div class="ally-icons" id="ally-icons"></div>
    </div>
  </div>
</div>

<div id="mobile-controls">
  <div class="dpad">
    <div></div>
    <div class="dpad-btn" data-dir="up">‚ñ≤</div>
    <div></div>
    <div class="dpad-btn" data-dir="left">‚óÄ</div>
    <div></div>
    <div class="dpad-btn" data-dir="right">‚ñ∂</div>
    <div></div>
    <div class="dpad-btn" data-dir="down">‚ñº</div>
    <div></div>
  </div>
  <div class="action-buttons">
    <div class="action-btn recruit-btn" id="recruit-btn">ALLY</div>
    <div class="action-btn attack-btn" id="attack-btn">ATK</div>
  </div>
</div>

<!-- TITLE SCREEN -->
<div class="screen" id="title-screen">
  <div class="title-potato">ü•î</div>
  <div class="game-title">POTATO SIMULATOR</div>
  <div class="subtitle">You are a brave potato. Battle evil utensils.<br>Recruit food allies. Survive 9 levels!</div>
  <button class="btn" id="start-btn">START GAME</button>
  <div style="color:#9a7a5a; margin-top:20px; font-size:14px; text-align:center; padding:0 20px;">
    Arrow keys / WASD to move &bull; SPACE to attack &bull; E to recruit allies
  </div>
  <a href="https://github.com/rlfordon/potato-simulator" target="_blank" style="color:#9a7a5a; margin-top:15px; font-size:13px; pointer-events:auto; text-decoration:none; opacity:0.7;">GitHub</a>
</div>

<!-- LEVEL SCREEN -->
<div class="screen" id="level-screen">
  <div class="level-title" id="level-title">Level 1</div>
  <div class="level-desc" id="level-desc"></div>
  <div class="enemy-preview" id="enemy-preview"></div>
  <button class="btn" id="go-btn">LET'S GO!</button>
</div>

<!-- GAME OVER -->
<div class="screen" id="game-over-screen">
  <div class="big-emoji" id="gameover-emoji">üòµ</div>
  <div class="game-title" id="gameover-title" style="font-size:clamp(28px,6vw,48px);color:#ff4444;">MASHED POTATO!</div>
  <div class="score-text">Score: <span id="final-score">0</span></div>
  <button class="btn" id="retry-btn">TRY AGAIN</button>
  <div style="color:#9a7a5a; margin-top:20px; font-size:13px; text-align:center; line-height:1.6;">
    Game design and sprite design by Calvin<br>
    <a href="https://github.com/rlfordon/potato-simulator" target="_blank" style="color:#9a7a5a; pointer-events:auto; text-decoration:none; opacity:0.7;">GitHub</a>
  </div>
</div>

<!-- WIN SCREEN -->
<div class="screen" id="win-screen">
  <div class="big-emoji">üëë</div>
  <div class="game-title" style="font-size:clamp(28px,6vw,48px);color:#44cc44;">POTATO CHAMPION!</div>
  <div class="score-text">Final Score: <span id="win-score">0</span></div>
  <div class="subtitle">You defeated Evil Pizza and escaped the kitchen!</div>
  <button class="btn" id="replay-btn">PLAY AGAIN</button>
  <div style="color:#ddb87a; margin-top:20px; font-size:15px; text-align:center; line-height:1.8;">
    Thanks for playing!<br>
    <span style="font-size:13px; color:#9a7a5a;">Game design and sprite design by Calvin</span><br>
    <a href="https://github.com/rlfordon/potato-simulator" target="_blank" style="color:#9a7a5a; font-size:13px; pointer-events:auto; text-decoration:none; opacity:0.7;">GitHub</a>
  </div>
</div>

<script src="test-config.js"></script>
<script>
// ============ GAME ENGINE ============
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);


// ============ SPRITE IMAGES ============
const spriteImages = {};
function loadSprite(name, path) {
  const img = new Image();
  img.src = path;
  spriteImages[name] = img;
}

loadSprite('potato', 'sprites/potato.png');
loadSprite('knife', 'sprites/knife.png');
loadSprite('fork', 'sprites/fork.png');
loadSprite('spoon', 'sprites/spoon.png');
loadSprite('fryer', 'sprites/fryer.png');
loadSprite('whisk', 'sprites/whisk.png');
loadSprite('cleaver', 'sprites/cleaver.png');
loadSprite('mixer', 'sprites/mixer.png');
loadSprite('rolling_pin', 'sprites/rolling_pin.png');
loadSprite('flame', 'sprites/flame.png');
loadSprite('frying_pan', 'sprites/frying_pan.png');
loadSprite('doughball', 'sprites/doughball.png');
loadSprite('pizza_slice', 'sprites/pizza_slice.png');
loadSprite('pizza', 'sprites/pizza.png');

// ============ GAME STATE ============
let gameState = 'title'; // title, levelIntro, playing, gameOver, win
let currentLevel = 1;
let score = 0;
let shakeTimer = 0;
let frameNow = 0; // cached Date.now() per frame

// Level definitions
const LEVELS = [
  {
    name: "The Sink",
    desc: "You fell in the sink! Forks are poking at you from the dish rack!",
    enemies: [
      { type: 'fork', count: 4 },
    ],
    ally: { type: 'carrot', emoji: 'ü•ï', name: 'Carrot' },
    bg: '#3a5a3a'
  },
  {
    name: "The Countertop",
    desc: "You climbed onto the counter! Knives are sliding toward you!",
    enemies: [
      { type: 'fork', count: 2 },
      { type: 'knife', count: 3 },
    ],
    ally: { type: 'broccoli', emoji: 'ü•¶', name: 'Broccoli' },
    bg: '#3a4a5a'
  },
  {
    name: "The Stovetop",
    desc: "It's getting hot! Spoons attack in groups on the stove!",
    enemies: [
      { type: 'knife', count: 2 },
      { type: 'spoon', count: 5 },
    ],
    ally: { type: 'tomato', emoji: 'üçÖ', name: 'Tomato' },
    bg: '#5a3a3a'
  },
  {
    name: "The Microwave",
    desc: "You rolled into the microwave... it's off for now. A whisk boss awaits!",
    enemies: [
      { type: 'fork', count: 2 },
      { type: 'knife', count: 2 },
      { type: 'spoon', count: 2 },
      { type: 'whisk', count: 1 },
    ],
    ally: { type: 'corn', emoji: 'üåΩ', name: 'Corn' },
    bg: '#4a3a5a'
  },
  {
    name: "MICROWAVE ON!!",
    desc: "Someone turned it on!! Defeat the Chef's Cleaver before you get cooked!",
    enemies: [
      { type: 'fork', count: 3 },
      { type: 'knife', count: 3 },
      { type: 'spoon', count: 3 },
      { type: 'cleaver', count: 1 },
    ],
    ally: null,
    bg: '#5a2a2a'
  },
  {
    name: "THE MIXER!!!",
    desc: "You fell into the MIXER! The Blender Boss is spinning up! SURVIVE!!",
    enemies: [
      { type: 'fork', count: 4 },
      { type: 'knife', count: 4 },
      { type: 'spoon', count: 4 },
      { type: 'whisk', count: 1 },
      { type: 'mixer', count: 1 },
    ],
    ally: null,
    bg: '#3a1a2a'
  },
  {
    name: "THE DEEP FRYER",
    desc: "OH NO! You're in the deep fryer! The Fryer Basket is trying to dunk you!",
    enemies: [
      { type: 'fork', count: 5 },
      { type: 'knife', count: 4 },
      { type: 'spoon', count: 4 },
      { type: 'whisk', count: 1 },
      { type: 'fryer', count: 1 },
    ],
    ally: null,
    bg: '#5a3a0a'
  },
  {
    name: "THE DOUGH COUNTER",
    desc: "You're on the dough rolling counter! Evil Pizza and the Rolling Pin want to flatten you!",
    enemies: [
      { type: 'fork', count: 4 },
      { type: 'knife', count: 3 },
      { type: 'spoon', count: 3 },
      { type: 'doughball', count: 3 },
      { type: 'pizza', count: 1 },
      { type: 'rolling_pin', count: 1 },
    ],
    ally: null,
    bg: '#5a4a3a'
  },
  {
    name: "THE STOVETOP RETURNS",
    enemies: [
      { type: 'fork', count: 3 },
      { type: 'knife', count: 3 },
      { type: 'spoon', count: 3 },
      { type: 'flame', count: 6 },
      { type: 'frying_pan', count: 1 },
    ],
    ally: null,
    bg: '#5a2a1a'
  }
];

// Enemy definitions
const ENEMY_DEFS = {
  fork: { emoji: 'üç¥', hp: 28, speed: 1.5, damage: 7, size: 30, score: 50, name: 'Fork' },
  knife: { emoji: 'üî™', hp: 40, speed: 2.2, damage: 10, size: 28, score: 80, name: 'Knife' },
  spoon: { emoji: 'ü•Ñ', hp: 24, speed: 1.7, damage: 5, size: 28, score: 40, name: 'Spoon' },
  whisk: { emoji: 'ü•¢', hp: 140, speed: 1.1, damage: 12, size: 50, score: 300, name: 'Whisk Boss' },
  cleaver: { emoji: 'ü™ì', hp: 220, speed: 0.9, damage: 16, size: 55, score: 500, name: 'Chef Cleaver' },
  mixer: { emoji: 'üåÄ', hp: 400, speed: 0.6, damage: 22, size: 65, score: 1000, name: 'THE MIXER' },
  fryer: { emoji: 'üß∫', hp: 500, speed: 0.5, damage: 25, size: 70, score: 1500, name: 'FRYER BASKET' },
  pizza: { emoji: 'üçï', hp: 350, speed: 0.7, damage: 18, size: 60, score: 2000, name: 'EVIL PIZZA' },
  pizza_slice: { emoji: 'üçï', hp: 50, speed: 2.0, damage: 10, size: 25, score: 150, name: 'Pizza Slice' },
  rolling_pin: { emoji: 'ü™µ', hp: 450, speed: 0.8, damage: 20, size: 55, score: 1800, name: 'ROLLING PIN' },
  doughball: { emoji: 'ü´ì', hp: 35, speed: 1.4, damage: 8, size: 30, score: 60, name: 'Dough Ball' },
  flame: { emoji: 'üî•', hp: 30, speed: 2.0, damage: 6, size: 28, score: 55, name: 'Flame' },
  frying_pan: { emoji: 'üç≥', hp: 400, speed: 0.7, damage: 20, size: 60, score: 2500, name: 'FRYING PAN' },
};

// Ally definitions
const ALLY_DEFS = {
  carrot: { emoji: 'ü•ï', hp: 50, damage: 6, speed: 1.5, size: 26 },
  broccoli: { emoji: 'ü•¶', hp: 65, damage: 5, speed: 1.3, size: 28 },
  tomato: { emoji: 'üçÖ', hp: 40, damage: 9, speed: 1.8, size: 24 },
  corn: { emoji: 'üåΩ', hp: 55, damage: 7, speed: 1.6, size: 26 },
  // Strong rare spawns
  watermelon: { emoji: 'üçâ', hp: 100, damage: 11, speed: 1.2, size: 34, strong: true },
  pineapple: { emoji: 'üçç', hp: 90, damage: 14, speed: 1.4, size: 32, strong: true },
  coconut: { emoji: 'ü••', hp: 120, damage: 8, speed: 1.0, size: 34, strong: true },
  chili: { emoji: 'üå∂Ô∏è', hp: 45, damage: 18, speed: 2.2, size: 24, strong: true },
  eggplant: { emoji: 'üçÜ', hp: 95, damage: 10, speed: 1.3, size: 30, strong: true },
};

const RANDOM_FOOD_NORMAL = ['carrot', 'broccoli', 'tomato', 'corn'];
const RANDOM_FOOD_STRONG = ['watermelon', 'pineapple', 'coconut', 'chili', 'eggplant'];
const FOOD_NAMES = {
  carrot: 'Carrot', broccoli: 'Broccoli', tomato: 'Tomato', corn: 'Corn',
  watermelon: 'Watermelon', pineapple: 'Pineapple', coconut: 'Coconut', chili: 'Chili Pepper', eggplant: 'Eggplant',
};

let foodSpawnTimer = 0;

// ============ ENTITIES ============
let player = null;
let enemies = [];
let allies = [];
let particles = [];
let foodPickups = []; // recruitable food on the ground
let projectiles = [];
let healthDrops = [];
let waveQueue = [];
let waveTimer = 0;

function createPlayer() {
  return {
    x: canvas.width / 2,
    y: canvas.height / 2,
    size: 35,
    hp: 120,
    maxHp: 120,
    speed: 4,
    damage: 20,
    attackCooldown: 0,
    attackRange: 80,
    invincible: 0,
    facing: 1, // 1 right, -1 left
  };
}

function spawnEnemies(level) {
  enemies = [];
  waveQueue = [];
  waveTimer = 0;
  const lvl = LEVELS[level - 1];
  const allEnemies = [];
  lvl.enemies.forEach(group => {
    const def = ENEMY_DEFS[group.type];
    for (let i = 0; i < group.count; i++) {
      // Spawn at edges
      let x, y;
      const side = Math.floor(Math.random() * 4);
      if (side === 0) { x = Math.random() * canvas.width; y = -40; }
      else if (side === 1) { x = canvas.width + 40; y = Math.random() * canvas.height; }
      else if (side === 2) { x = Math.random() * canvas.width; y = canvas.height + 40; }
      else { x = -40; y = Math.random() * canvas.height; }

      allEnemies.push({
        x, y,
        type: group.type,
        emoji: def.emoji,
        hp: def.hp,
        maxHp: def.hp,
        speed: def.speed + Math.random() * 0.3,
        damage: def.damage,
        size: def.size,
        score: def.score,
        attackCooldown: 0,
        hit: 0,
        kbx: 0, kby: 0,
        angle: Math.random() * Math.PI * 2,
        bobOffset: Math.random() * Math.PI * 2,
      });
    }
  });
  
  // Shuffle enemies
  for (let i = allEnemies.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [allEnemies[i], allEnemies[j]] = [allEnemies[j], allEnemies[i]];
  }
  
  // First wave: send 3-4 enemies immediately (always include bosses)
  const bosses = allEnemies.filter(e => ['whisk','cleaver','mixer','fryer','pizza','rolling_pin','frying_pan'].includes(e.type));
  const regular = allEnemies.filter(e => !['whisk','cleaver','mixer','fryer','pizza','rolling_pin','frying_pan'].includes(e.type));
  
  const firstBatch = Math.min(3, regular.length);
  enemies = regular.splice(0, firstBatch).concat(bosses);
  waveQueue = [...regular];
}

function spawnFoodPickup(level) {
  const lvl = LEVELS[level - 1];
  if (!lvl.ally) return;
  const def = ALLY_DEFS[lvl.ally.type];
  foodPickups.push({
    x: 100 + Math.random() * (canvas.width - 200),
    y: 100 + Math.random() * (canvas.height - 200),
    type: lvl.ally.type,
    emoji: lvl.ally.emoji,
    name: lvl.ally.name,
    strong: def.strong || false,
    size: 30,
    bobOffset: Math.random() * Math.PI * 2,
    glow: 0,
  });
}

function spawnRandomFood() {
  if (foodPickups.length >= 4) return; // max 4 pickups on screen
  // 35% chance of strong food
  const isStrong = Math.random() < 0.35;
  const pool = isStrong ? RANDOM_FOOD_STRONG : RANDOM_FOOD_NORMAL;
  const type = pool[Math.floor(Math.random() * pool.length)];
  const def = ALLY_DEFS[type];
  foodPickups.push({
    x: 60 + Math.random() * (canvas.width - 120),
    y: 60 + Math.random() * (canvas.height - 120),
    type: type,
    emoji: def.emoji,
    name: FOOD_NAMES[type],
    strong: def.strong || false,
    size: def.strong ? 36 : 30,
    bobOffset: Math.random() * Math.PI * 2,
    glow: 0,
  });
  if (isStrong) {
    createFloatingText(canvas.width / 2, 80, '‚≠ê Rare food appeared!', '#44aaff');
  }
}

function recruitAlly(pickup) {
  const def = ALLY_DEFS[pickup.type];
  // Cap at 3 allies max
  if (allies.length >= 5) return;
  allies.push({
    x: pickup.x,
    y: pickup.y,
    type: pickup.type,
    emoji: pickup.emoji,
    hp: def.hp,
    maxHp: def.hp,
    damage: def.damage,
    speed: def.speed,
    size: def.size,
    strong: def.strong || false,
    attackCooldown: 0,
    target: null,
    hit: 0,
    bobOffset: Math.random() * Math.PI * 2,
  });
  spawnParticles(pickup.x, pickup.y, pickup.strong ? '#44aaff' : '#44ff44', 15);
  const label = pickup.strong ? `‚≠ê ${pickup.emoji} joined!` : `${pickup.emoji} joined!`;
  createFloatingText(pickup.x, pickup.y, label, pickup.strong ? '#44aaff' : '#44ff44');
}

// ============ INPUT ============
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if (['arrowup','arrowdown','arrowleft','arrowright',' '].includes(e.key.toLowerCase())) {
    e.preventDefault();
  }
});
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

// Mobile controls
document.querySelectorAll('.dpad-btn').forEach(btn => {
  const dir = btn.dataset.dir;
  const keyMap = { up: 'arrowup', down: 'arrowdown', left: 'arrowleft', right: 'arrowright' };
  btn.addEventListener('touchstart', e => { e.preventDefault(); keys[keyMap[dir]] = true; });
  btn.addEventListener('touchend', e => { e.preventDefault(); keys[keyMap[dir]] = false; });
});

document.getElementById('attack-btn').addEventListener('touchstart', e => { e.preventDefault(); keys[' '] = true; });
document.getElementById('attack-btn').addEventListener('touchend', e => { e.preventDefault(); keys[' '] = false; });
document.getElementById('recruit-btn').addEventListener('touchstart', e => { e.preventDefault(); keys['e'] = true; });
document.getElementById('recruit-btn').addEventListener('touchend', e => { e.preventDefault(); keys['e'] = false; });

// ============ PARTICLES & EFFECTS ============
function spawnParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 8,
      vy: (Math.random() - 0.5) * 8,
      life: 1,
      color,
      size: 3 + Math.random() * 5,
    });
  }
}

function createFloatingText(x, y, text, color) {
  const el = document.createElement('div');
  el.className = 'floating-text';
  el.textContent = text;
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  el.style.color = color;
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 1000);
}

function flashDamage() {
  const el = document.createElement('div');
  el.className = 'damage-flash';
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 300);
}

// ============ DRAWING ============
// ============ HAND-DRAWN STYLE HELPERS ============
// Makes lines wobbly like drawn by a kid with a marker
function wobblyLine(x1, y1, x2, y2, wobble) {
  const segs = 4;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  for (let i = 1; i <= segs; i++) {
    const t = i / segs;
    const mx = x1 + (x2 - x1) * t + (Math.sin(t * 20 + x1 + y1) * wobble);
    const my = y1 + (y2 - y1) * t + (Math.cos(t * 20 + x1 + y1) * wobble);
    ctx.lineTo(mx, my);
  }
  ctx.stroke();
}

// Draws a wobbly circle/ellipse like a kid would
function wobblyEllipse(cx, cy, rx, ry, wobble) {
  ctx.beginPath();
  const pts = 12;
  for (let i = 0; i <= pts; i++) {
    const a = (i / pts) * Math.PI * 2;
    const wx = cx + Math.cos(a) * (rx + (Math.sin(a * 3 + cx) * wobble));
    const wy = cy + Math.sin(a) * (ry + (Math.cos(a * 2 + cy) * wobble));
    if (i === 0) ctx.moveTo(wx, wy);
    else ctx.lineTo(wx, wy);
  }
  ctx.closePath();
}

// Sketchy fill + stroke combo
function sketchShape(fillColor, strokeColor, lineWidth) {
  if (fillColor) { ctx.fillStyle = fillColor; ctx.fill(); }
  if (strokeColor) { ctx.strokeStyle = strokeColor; ctx.lineWidth = lineWidth || 2.5; ctx.stroke(); }
}

// ============ CUSTOM SPRITE DRAWINGS ============

function drawFryerBasket(x, y, size, bob) {
  ctx.save();
  ctx.translate(x, y + bob);
  const s = size / 35;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  // Handle
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 3.5 * s;
  ctx.beginPath();
  ctx.moveTo(10 * s, -16 * s);
  ctx.lineTo(12 * s, -30 * s);
  ctx.lineTo(28 * s, -31 * s);
  ctx.lineTo(29 * s, -24 * s);
  ctx.stroke();
  wobblyEllipse(30 * s, -28 * s, 7 * s, 5 * s, 1.5 * s);
  sketchShape('#555', '#333', 2.5 * s);

  // Basket body
  ctx.beginPath();
  ctx.moveTo(-26 * s, -14 * s);
  ctx.lineTo(22 * s, -15 * s);
  ctx.lineTo(17 * s, 18 * s);
  ctx.lineTo(-21 * s, 17 * s);
  ctx.closePath();
  sketchShape('#999', '#444', 3 * s);

  // Wire grid
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 1.5 * s;
  for (let i = -18; i <= 16; i += 7) {
    wobblyLine(i * s, -14 * s, (i * 0.85) * s, 17 * s, 1.5 * s);
  }
  for (let j = -8; j <= 12; j += 7) {
    const r = (j + 14) / 32;
    wobblyLine((-26 + r * 5) * s, j * s, (22 - r * 5) * s, j * s, 1.5 * s);
  }

  // Eyes
  wobblyEllipse(-10 * s, -2 * s, 6 * s, 5.5 * s, 1 * s);
  sketchShape('#fff', '#333', 2 * s);
  wobblyEllipse(7 * s, -2 * s, 5 * s, 5 * s, 1 * s);
  sketchShape('#fff', '#333', 2 * s);
  ctx.fillStyle = '#111';
  ctx.beginPath(); ctx.arc(-9 * s, -1 * s, 3 * s, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(8 * s, -1 * s, 2.5 * s, 0, Math.PI * 2); ctx.fill();

  // Angry eyebrows
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 3 * s;
  wobblyLine(-17 * s, -10 * s, -5 * s, -6 * s, 1 * s);
  wobblyLine(15 * s, -10 * s, 4 * s, -6 * s, 1 * s);

  // Mean grin with teeth
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 2.5 * s;
  ctx.beginPath();
  ctx.moveTo(-11 * s, 8 * s);
  ctx.quadraticCurveTo(-1 * s, 16 * s, 10 * s, 8 * s);
  ctx.stroke();
  ctx.fillStyle = '#fff';
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1 * s;
  ctx.fillRect(-6 * s, 8 * s, 4 * s, 4 * s); ctx.strokeRect(-6 * s, 8 * s, 4 * s, 4 * s);
  ctx.fillRect(1 * s, 8 * s, 4 * s, 4 * s); ctx.strokeRect(1 * s, 8 * s, 4 * s, 4 * s);

  ctx.restore();
}

function drawFork(x, y, size, bob) {
  ctx.save();
  ctx.translate(x, y + bob);
  const s = size / 30;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  // Handle
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 4 * s;
  wobblyLine(0, 10 * s, 0, 28 * s, 2 * s);

  // Head
  ctx.beginPath();
  ctx.moveTo(-12 * s, -8 * s);
  ctx.lineTo(-12 * s, 12 * s);
  ctx.lineTo(12 * s, 12 * s);
  ctx.lineTo(12 * s, -8 * s);
  ctx.closePath();
  sketchShape('#bbb', '#444', 2.5 * s);

  // Tines
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 3 * s;
  wobblyLine(-8 * s, -8 * s, -9 * s, -26 * s, 2 * s);
  wobblyLine(0, -8 * s, 1 * s, -28 * s, 2 * s);
  wobblyLine(8 * s, -8 * s, 7 * s, -25 * s, 2 * s);

  // Face
  ctx.fillStyle = '#222';
  ctx.beginPath(); ctx.arc(-5 * s, 1 * s, 2.5 * s, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(5 * s, 1 * s, 2.5 * s, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 2 * s;
  ctx.beginPath();
  ctx.moveTo(-5 * s, 7 * s);
  ctx.lineTo(0, 5 * s);
  ctx.lineTo(5 * s, 7 * s);
  ctx.stroke();

  ctx.restore();
}

function drawKnife(x, y, size, bob) {
  ctx.save();
  ctx.translate(x, y + bob);
  const s = size / 28;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  // Blade
  ctx.beginPath();
  ctx.moveTo(0, -30 * s);
  ctx.lineTo(11 * s, -5 * s);
  ctx.lineTo(11 * s, 2 * s);
  ctx.lineTo(-4 * s, 2 * s);
  ctx.closePath();
  sketchShape('#ccc', '#444', 2.5 * s);

  // Edge shine
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 1.5 * s;
  wobblyLine(-1 * s, -25 * s, 9 * s, -5 * s, 1 * s);

  // Handle
  ctx.beginPath();
  ctx.moveTo(-5 * s, 2 * s);
  ctx.lineTo(12 * s, 2 * s);
  ctx.lineTo(11 * s, 22 * s);
  ctx.lineTo(-4 * s, 21 * s);
  ctx.closePath();
  sketchShape('#664422', '#333', 2.5 * s);

  // Rivets
  ctx.fillStyle = '#888';
  ctx.beginPath(); ctx.arc(3 * s, 7 * s, 2 * s, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(3 * s, 15 * s, 2 * s, 0, Math.PI * 2); ctx.fill();

  // Mean eyes on blade
  ctx.fillStyle = '#c00';
  ctx.beginPath(); ctx.arc(2 * s, -14 * s, 3 * s, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(7 * s, -10 * s, 2.5 * s, 0, Math.PI * 2); ctx.fill();
  // Tiny pupils
  ctx.fillStyle = '#400';
  ctx.beginPath(); ctx.arc(2 * s, -14 * s, 1.5 * s, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(7 * s, -10 * s, 1.2 * s, 0, Math.PI * 2); ctx.fill();

  ctx.restore();
}

function drawSpoon(x, y, size, bob) {
  ctx.save();
  ctx.translate(x, y + bob);
  const s = size / 28;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  // Handle
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 4 * s;
  wobblyLine(0, 8 * s, -1 * s, 28 * s, 2 * s);

  // Spoon bowl
  wobblyEllipse(0, -6 * s, 14 * s, 16 * s, 2.5 * s);
  sketchShape('#bbb', '#555', 2.5 * s);

  // Inner shadow
  wobblyEllipse(0, -4 * s, 9 * s, 10 * s, 1.5 * s);
  sketchShape('rgba(0,0,0,0.1)', null, 0);

  // Dopey face
  ctx.fillStyle = '#333';
  ctx.beginPath(); ctx.arc(-5 * s, -8 * s, 3 * s, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(5 * s, -8 * s, 3 * s, 0, Math.PI * 2); ctx.fill();
  // Eye shine
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(-6 * s, -9 * s, 1 * s, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(4 * s, -9 * s, 1 * s, 0, Math.PI * 2); ctx.fill();
  // Mouth
  wobblyEllipse(0, -1 * s, 4 * s, 3 * s, 1 * s);
  sketchShape('#444', '#333', 1.5 * s);

  ctx.restore();
}

function drawWhisk(x, y, size, bob) {
  ctx.save();
  ctx.translate(x, y + bob);
  const s = size / 50;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  // Handle
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 5 * s;
  wobblyLine(0, 15 * s, 1 * s, 35 * s, 2 * s);

  // Whisk wires
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 2.5 * s;
  for (let i = 0; i < 6; i++) {
    const spread = (i - 2.5) * 6;
    ctx.beginPath();
    ctx.moveTo(0, 15 * s);
    ctx.quadraticCurveTo((spread + Math.sin(i) * 2) * s, -10 * s, (spread * 0.3 + Math.cos(i) * 1.5) * s, -30 * s);
    ctx.stroke();
  }
  wobblyLine(-7 * s, -29 * s, 7 * s, -29 * s, 2 * s);

  // Boss face on handle
  ctx.fillStyle = '#c00';
  ctx.beginPath(); ctx.arc(-6 * s, 22 * s, 3.5 * s, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(6 * s, 22 * s, 3.5 * s, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(-5.5 * s, 21.5 * s, 1.2 * s, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(6.5 * s, 21.5 * s, 1.2 * s, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#800';
  ctx.lineWidth = 2.5 * s;
  ctx.beginPath();
  ctx.moveTo(-5 * s, 28 * s);
  ctx.quadraticCurveTo(0, 33 * s, 5 * s, 28 * s);
  ctx.stroke();

  ctx.restore();
}

function drawCleaver(x, y, size, bob) {
  ctx.save();
  ctx.translate(x, y + bob);
  const s = size / 55;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  // Big blade
  ctx.beginPath();
  ctx.moveTo(-20 * s, -25 * s);
  ctx.lineTo(16 * s, -24 * s);
  ctx.lineTo(17 * s, 11 * s);
  ctx.lineTo(-20 * s, 13 * s);
  ctx.closePath();
  sketchShape('#bbb', '#444', 3 * s);

  // Sharp edge
  ctx.strokeStyle = '#ddd';
  ctx.lineWidth = 2 * s;
  wobblyLine(-20 * s, 13 * s, 17 * s, 11 * s, 1.5 * s);

  // Handle
  ctx.beginPath();
  ctx.moveTo(-6 * s, -25 * s);
  ctx.lineTo(6 * s, -25 * s);
  ctx.lineTo(5 * s, -42 * s);
  ctx.lineTo(-5 * s, -41 * s);
  ctx.closePath();
  sketchShape('#553311', '#333', 2.5 * s);

  // Scary face
  wobblyEllipse(-8 * s, -8 * s, 5 * s, 5 * s, 1 * s);
  sketchShape('#800', null, 0);
  wobblyEllipse(6 * s, -8 * s, 5 * s, 5 * s, 1 * s);
  sketchShape('#800', null, 0);
  // Yellow pupils
  ctx.fillStyle = '#ff0';
  ctx.beginPath(); ctx.arc(-7 * s, -8 * s, 2 * s, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(7 * s, -8 * s, 2 * s, 0, Math.PI * 2); ctx.fill();
  // Jagged mouth
  ctx.strokeStyle = '#600';
  ctx.lineWidth = 2.5 * s;
  ctx.beginPath();
  ctx.moveTo(-10 * s, 1 * s);
  ctx.lineTo(-5 * s, 5 * s); ctx.lineTo(0, 1 * s);
  ctx.lineTo(5 * s, 5 * s); ctx.lineTo(10 * s, 1 * s);
  ctx.stroke();

  ctx.restore();
}

function drawMixer(x, y, size, bob) {
  ctx.save();
  ctx.translate(x, y + bob);
  const s = size / 65;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  const spin = frameNow / 150;

  // Motor body
  ctx.beginPath();
  ctx.moveTo(-16 * s, -22 * s);
  ctx.lineTo(16 * s, -21 * s);
  ctx.lineTo(13 * s, -5 * s);
  ctx.lineTo(-13 * s, -5 * s);
  ctx.closePath();
  sketchShape('#777', '#333', 3 * s);

  // Spinning blades
  ctx.save();
  ctx.rotate(spin);
  ctx.strokeStyle = '#aaa';
  ctx.lineWidth = 3.5 * s;
  for (let i = 0; i < 4; i++) {
    const a = (i / 4) * Math.PI * 2;
    wobblyLine(0, 0, Math.cos(a) * 25 * s, Math.sin(a) * 25 * s, 2 * s);
  }
  ctx.restore();

  // Center hub
  wobblyEllipse(0, 0, 8 * s, 8 * s, 1.5 * s);
  sketchShape('#555', '#333', 2 * s);

  // Angry face on motor
  ctx.fillStyle = '#f00';
  ctx.beginPath(); ctx.arc(-6 * s, -15 * s, 3.5 * s, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(6 * s, -15 * s, 3.5 * s, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(-5.5 * s, -15.5 * s, 1.2 * s, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(6.5 * s, -15.5 * s, 1.2 * s, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#900';
  ctx.lineWidth = 2.5 * s;
  ctx.beginPath();
  ctx.moveTo(-5 * s, -9 * s);
  ctx.lineTo(0, -7 * s);
  ctx.lineTo(5 * s, -9 * s);
  ctx.stroke();

  ctx.restore();
}

// ============ DRAW ENTITY ============
function drawEntity(entity, emoji, size, isHurt, isAlly) {
  ctx.save();
  ctx.translate(entity.x, entity.y);

  if (isHurt && entity.hit > 0) {
    ctx.filter = 'brightness(3)';
  }

  const bob = Math.sin(frameNow / 300 + (entity.bobOffset || 0)) * 3;

  if (isAlly) {
    const pulse = Math.sin(frameNow / 400) * 0.15 + 0.85;
    ctx.strokeStyle = `rgba(60,140,255,${0.8 * pulse})`;
    ctx.lineWidth = 3;
    wobblyEllipse(0, bob, size * 1.0, size * 1.0, 2);
    ctx.stroke();
    ctx.fillStyle = 'rgba(40,100,220,0.15)';
    ctx.fill();
  } else {
    ctx.fillStyle = 'rgba(60,30,30,0.45)';
    wobblyEllipse(0, bob, size * 0.85, size * 0.85, 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,60,60,0.35)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  // Try sprite image first, fall back to canvas drawing, then emoji
  const spriteImg = spriteImages[entity.type];
  if (spriteImg && spriteImg.complete && spriteImg.naturalWidth > 0) {
    // Draw the sprite image, scaled to fit the entity size
    const imgW = spriteImg.naturalWidth;
    const imgH = spriteImg.naturalHeight;
    const drawH = size * 2.2;
    const drawW = drawH * (imgW / imgH);
    ctx.drawImage(spriteImg, -drawW / 2, -drawH / 2 + bob, drawW, drawH);
  } else {
    const spriteDrawers = {
      fork: drawFork,
      knife: drawKnife,
      spoon: drawSpoon,
      whisk: drawWhisk,
      cleaver: drawCleaver,
      mixer: drawMixer,
      fryer: drawFryerBasket,
    };
    if (spriteDrawers[entity.type]) {
      spriteDrawers[entity.type](0, 0, size, bob);
    } else {
      ctx.font = `${size}px serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(emoji, 0, bob);
    }
  }

  if (isAlly && entity.strong) {
    ctx.font = '14px serif';
    ctx.fillText('‚≠ê', size * 0.7, -size * 0.7 + bob);
  }

  ctx.filter = 'none';

  if (entity.hp < entity.maxHp && entity.hp > 0) {
    const barW = size * 1.5;
    const barH = 6;
    const barY = -size / 2 - 14 + bob;
    ctx.fillStyle = '#333';
    ctx.fillRect(-barW / 2 - 1, barY - 1, barW + 2, barH + 2);
    const hpRatio = entity.hp / entity.maxHp;
    ctx.fillStyle = hpRatio > 0.5 ? '#44cc44' : hpRatio > 0.25 ? '#ffaa00' : '#ff4444';
    ctx.fillRect(-barW / 2, barY, barW * hpRatio, barH);
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(-barW / 2, barY, barW, barH);
  }

  ctx.restore();
}

function drawPotato(p) {
  ctx.save();
  ctx.translate(p.x, p.y);

  const bob = Math.sin(frameNow / 250) * 3;
  const scale = p.invincible > 0 ? 1 + Math.sin(frameNow / 50) * 0.05 : 1;

  if (p.invincible > 0 && Math.floor(frameNow / 80) % 2 === 0) {
    ctx.globalAlpha = 0.4;
  }

  ctx.scale(p.facing * scale, scale);

  // Draw potato sprite image
  const spriteImg = spriteImages['potato'];
  if (spriteImg && spriteImg.complete && spriteImg.naturalWidth > 0) {
    const imgW = spriteImg.naturalWidth;
    const imgH = spriteImg.naturalHeight;
    const drawH = 70;
    const drawW = drawH * (imgW / imgH);
    ctx.drawImage(spriteImg, -drawW / 2, -drawH / 2 + bob, drawW, drawH);
  } else {
    // Fallback to canvas drawing
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    wobblyEllipse(0, bob, 28, 33, 3);
    sketchShape('#c4a265', '#5a4020', 3);
    ctx.fillStyle = '#222';
    ctx.beginPath(); ctx.arc(-7, -5 + bob, 3.5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(11, -5 + bob, 3.5, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = '#5a4020';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.arc(0, 6 + bob, 9, 0.15 * Math.PI, 0.85 * Math.PI);
    ctx.stroke();
  }

  // Attack swipe (always draw on top)
  if (p.attackCooldown > 12) {
    ctx.strokeStyle = '#ffcc00';
    ctx.lineWidth = 3;
    const swingProgress = (p.attackCooldown - 12) / 8;
    for (let i = 0; i < 3; i++) {
      const a = (swingProgress * Math.PI) - 0.5 + i * 0.3;
      const r = p.attackRange * (0.4 + i * 0.15);
      ctx.beginPath();
      ctx.moveTo(25 + Math.cos(a) * r * 0.5, bob + Math.sin(a) * r * 0.5);
      ctx.lineTo(25 + Math.cos(a) * r, bob + Math.sin(a) * r);
      ctx.stroke();
    }
  }

  ctx.restore();
}

function drawBackground(level) {
  const lvl = LEVELS[level - 1];
  
  if (level === 1) {
    // === SINK ===
    // Steel sink basin
    ctx.fillStyle = '#b8c4cc';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Brushed steel texture lines
    for (let y = 0; y < canvas.height; y += 4) {
      ctx.fillStyle = y % 8 === 0 ? 'rgba(180,195,210,0.5)' : 'rgba(150,165,180,0.3)';
      ctx.fillRect(0, y, canvas.width, 2);
    }
    
    // Sink basin (darker recessed area)
    const basinX = canvas.width * 0.1;
    const basinY = canvas.height * 0.1;
    const basinW = canvas.width * 0.8;
    const basinH = canvas.height * 0.8;
    ctx.fillStyle = '#8a9aaa';
    ctx.beginPath();
    ctx.roundRect(basinX, basinY, basinW, basinH, 30);
    ctx.fill();
    
    // Basin inner shadow
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.beginPath();
    ctx.roundRect(basinX + 5, basinY + 5, basinW - 10, basinH - 10, 25);
    ctx.fill();
    
    ctx.fillStyle = '#7a8a9a';
    ctx.beginPath();
    ctx.roundRect(basinX + 10, basinY + 10, basinW - 20, basinH - 20, 20);
    ctx.fill();
    
    // Drain in center
    ctx.fillStyle = '#555';
    ctx.beginPath();
    ctx.arc(canvas.width / 2, canvas.height / 2, 25, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(canvas.width / 2, canvas.height / 2, 18, 0, Math.PI * 2);
    ctx.fill();
    // Drain holes
    for (let a = 0; a < Math.PI * 2; a += Math.PI / 4) {
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.arc(canvas.width / 2 + Math.cos(a) * 10, canvas.height / 2 + Math.sin(a) * 10, 3, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Water droplets scattered around
    for (let i = 0; i < 20; i++) {
      const wx = 80 + ((i * 137) % (canvas.width - 160));
      const wy = 80 + ((i * 211) % (canvas.height - 160));
      ctx.fillStyle = 'rgba(170,210,240,0.4)';
      ctx.beginPath();
      ctx.ellipse(wx, wy, 4 + (i % 3) * 2, 3 + (i % 2) * 2, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Faucet at top
    ctx.fillStyle = '#9aa';
    ctx.fillRect(canvas.width / 2 - 15, 0, 30, 50);
    ctx.fillStyle = '#8a9a9a';
    ctx.beginPath();
    ctx.arc(canvas.width / 2, 50, 18, 0, Math.PI);
    ctx.fill();
    // Faucet spout
    ctx.fillStyle = '#9aa';
    ctx.fillRect(canvas.width / 2 - 6, 50, 12, 30);
    // Drip
    const dripY = 80 + Math.sin(frameNow / 500) * 3;
    ctx.fillStyle = 'rgba(100,180,240,0.6)';
    ctx.beginPath();
    ctx.ellipse(canvas.width / 2, dripY + 5, 3, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    
  } else if (level === 2) {
    // === COUNTER ===
    // Wooden countertop
    ctx.fillStyle = '#c4956a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Wood grain
    for (let y = 0; y < canvas.height; y += 35) {
      ctx.strokeStyle = `rgba(160,110,70,${0.2 + (y % 70 === 0 ? 0.15 : 0)})`;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(0, y);
      for (let x = 0; x < canvas.width; x += 20) {
        ctx.lineTo(x, y + Math.sin(x / 80 + y) * 3);
      }
      ctx.stroke();
    }
    
    // Wood knots
    const knots = [[canvas.width*0.2, canvas.height*0.3], [canvas.width*0.7, canvas.height*0.6], [canvas.width*0.5, canvas.height*0.8]];
    knots.forEach(([kx, ky]) => {
      ctx.fillStyle = 'rgba(140,90,50,0.3)';
      ctx.beginPath();
      ctx.ellipse(kx, ky, 18, 12, 0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(130,85,45,0.25)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.ellipse(kx, ky, 25, 18, 0.3, 0, Math.PI * 2);
      ctx.stroke();
    });
    
    // Cutting board
    ctx.fillStyle = '#d4a870';
    ctx.beginPath();
    ctx.roundRect(canvas.width * 0.65, canvas.height * 0.05, canvas.width * 0.3, canvas.height * 0.2, 8);
    ctx.fill();
    ctx.strokeStyle = '#b08850';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(canvas.width * 0.65, canvas.height * 0.05, canvas.width * 0.3, canvas.height * 0.2, 8);
    ctx.stroke();
    
    // Salt and pepper shakers (top left)
    // Salt
    ctx.fillStyle = '#eee';
    ctx.beginPath();
    ctx.roundRect(30, 20, 22, 40, 6);
    ctx.fill();
    ctx.fillStyle = '#ccc';
    ctx.beginPath();
    ctx.roundRect(30, 20, 22, 10, [6,6,0,0]);
    ctx.fill();
    // Pepper
    ctx.fillStyle = '#444';
    ctx.beginPath();
    ctx.roundRect(60, 20, 22, 40, 6);
    ctx.fill();
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.roundRect(60, 20, 22, 10, [6,6,0,0]);
    ctx.fill();
    
    // Counter edge (bottom)
    ctx.fillStyle = '#a07040';
    ctx.fillRect(0, canvas.height - 12, canvas.width, 12);
    
    // Tile backsplash (top)
    ctx.fillStyle = '#e8e0d0';
    ctx.fillRect(0, 0, canvas.width, 10);
    
  } else if (level === 3) {
    // === STOVE ===
    // Black stovetop
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Subtle texture
    for (let x = 0; x < canvas.width; x += 3) {
      for (let y = 0; y < canvas.height; y += 3) {
        if (Math.random() < 0.08) {
          ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.04})`;
          ctx.fillRect(x, y, 2, 2);
        }
      }
    }
    
    // Four burners
    const burnerPositions = [
      [canvas.width * 0.25, canvas.height * 0.3],
      [canvas.width * 0.75, canvas.height * 0.3],
      [canvas.width * 0.25, canvas.height * 0.7],
      [canvas.width * 0.75, canvas.height * 0.7],
    ];
    
    burnerPositions.forEach(([bx, by], i) => {
      const radius = Math.min(canvas.width, canvas.height) * 0.15;
      // Burner ring
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(bx, by, radius, 0, Math.PI * 2);
      ctx.stroke();
      // Inner ring
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(bx, by, radius * 0.65, 0, Math.PI * 2);
      ctx.stroke();
      // Center
      ctx.fillStyle = '#383838';
      ctx.beginPath();
      ctx.arc(bx, by, radius * 0.3, 0, Math.PI * 2);
      ctx.fill();
      
      // One burner is on (glowing red) - front left
      if (i === 2) {
        ctx.strokeStyle = `rgba(255,${80 + Math.sin(frameNow/200)*30},0,0.7)`;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.arc(bx, by, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.strokeStyle = `rgba(255,${60 + Math.sin(frameNow/150)*20},0,0.4)`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(bx, by, radius * 0.65, 0, Math.PI * 2);
        ctx.stroke();
        // Glow
        const grad = ctx.createRadialGradient(bx, by, 0, bx, by, radius * 1.3);
        grad.addColorStop(0, 'rgba(255,60,0,0.15)');
        grad.addColorStop(1, 'rgba(255,60,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(bx, by, radius * 1.3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Grate lines
      ctx.strokeStyle = '#505050';
      ctx.lineWidth = 4;
      for (let g = -1; g <= 1; g += 2) {
        ctx.beginPath();
        ctx.moveTo(bx - radius, by + g * radius * 0.3);
        ctx.lineTo(bx + radius, by + g * radius * 0.3);
        ctx.stroke();
      }
    });
    
    // Stove edge
    ctx.fillStyle = '#444';
    ctx.fillRect(0, 0, canvas.width, 6);
    ctx.fillRect(0, canvas.height - 6, canvas.width, 6);
    ctx.fillRect(0, 0, 6, canvas.height);
    ctx.fillRect(canvas.width - 6, 0, 6, canvas.height);
    
  } else if (level === 4) {
    // === MICROWAVE (OFF) ===
    // Interior of microwave - cream/beige
    ctx.fillStyle = '#d8d0c0';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Interior walls - slight shadow gradient
    const wallGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    wallGrad.addColorStop(0, 'rgba(0,0,0,0.08)');
    wallGrad.addColorStop(0.5, 'rgba(0,0,0,0)');
    wallGrad.addColorStop(1, 'rgba(0,0,0,0.12)');
    ctx.fillStyle = wallGrad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Glass turntable plate
    const plateX = canvas.width / 2;
    const plateY = canvas.height / 2;
    const plateR = Math.min(canvas.width, canvas.height) * 0.32;
    ctx.fillStyle = 'rgba(200,220,230,0.25)';
    ctx.beginPath();
    ctx.arc(plateX, plateY, plateR, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(180,200,210,0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(plateX, plateY, plateR, 0, Math.PI * 2);
    ctx.stroke();
    // Inner ring on plate
    ctx.strokeStyle = 'rgba(180,200,210,0.25)';
    ctx.beginPath();
    ctx.arc(plateX, plateY, plateR * 0.6, 0, Math.PI * 2);
    ctx.stroke();
    
    // Microwave walls (border)
    ctx.fillStyle = '#888';
    ctx.fillRect(0, 0, canvas.width, 10);
    ctx.fillRect(0, canvas.height - 10, canvas.width, 10);
    ctx.fillRect(0, 0, 10, canvas.height);
    ctx.fillRect(canvas.width - 10, 0, 10, canvas.height);
    
    // Corner rivets
    [[20, 20], [canvas.width - 20, 20], [20, canvas.height - 20], [canvas.width - 20, canvas.height - 20]].forEach(([rx, ry]) => {
      ctx.fillStyle = '#999';
      ctx.beginPath();
      ctx.arc(rx, ry, 4, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // Door mesh pattern on right side (window)
    ctx.fillStyle = 'rgba(0,0,0,0.05)';
    ctx.fillRect(canvas.width - 50, 10, 40, canvas.height - 20);
    for (let y = 15; y < canvas.height - 15; y += 8) {
      ctx.fillStyle = 'rgba(0,0,0,0.06)';
      ctx.fillRect(canvas.width - 48, y, 36, 1);
    }
    
  } else if (level === 5) {
    // === MICROWAVE (ON!) ===
    // Interior glowing
    const pulse = Math.sin(frameNow / 300) * 0.1 + 0.9;
    ctx.fillStyle = `rgb(${Math.floor(200 * pulse)},${Math.floor(180 * pulse)},${Math.floor(140 * pulse)})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Yellowish microwave glow
    const glowGrad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width * 0.6);
    glowGrad.addColorStop(0, `rgba(255,230,100,${0.2 * pulse})`);
    glowGrad.addColorStop(1, 'rgba(255,200,50,0)');
    ctx.fillStyle = glowGrad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Spinning turntable
    const plateX = canvas.width / 2;
    const plateY = canvas.height / 2;
    const plateR = Math.min(canvas.width, canvas.height) * 0.32;
    const spinAngle = frameNow / 2000;
    
    ctx.save();
    ctx.translate(plateX, plateY);
    ctx.rotate(spinAngle);
    ctx.fillStyle = 'rgba(200,220,230,0.3)';
    ctx.beginPath();
    ctx.arc(0, 0, plateR, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(180,200,210,0.5)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, plateR, 0, Math.PI * 2);
    ctx.stroke();
    // Spoke marks on plate to show rotation
    ctx.strokeStyle = 'rgba(180,200,210,0.2)';
    for (let a = 0; a < Math.PI * 2; a += Math.PI / 3) {
      ctx.beginPath();
      ctx.moveTo(Math.cos(a) * plateR * 0.3, Math.sin(a) * plateR * 0.3);
      ctx.lineTo(Math.cos(a) * plateR * 0.9, Math.sin(a) * plateR * 0.9);
      ctx.stroke();
    }
    ctx.restore();
    
    // Microwave sparks / energy
    for (let i = 0; i < 5; i++) {
      const sparkX = (frameNow / 3 + i * 300) % canvas.width;
      const sparkY = Math.sin(frameNow / 200 + i * 1.5) * canvas.height * 0.3 + canvas.height / 2;
      ctx.fillStyle = `rgba(255,255,150,${0.3 + Math.sin(frameNow/100 + i) * 0.2})`;
      ctx.beginPath();
      ctx.arc(sparkX, sparkY, 2 + Math.random() * 3, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Walls (heated metal look)
    ctx.fillStyle = '#777';
    ctx.fillRect(0, 0, canvas.width, 10);
    ctx.fillRect(0, canvas.height - 10, canvas.width, 10);
    ctx.fillRect(0, 0, 10, canvas.height);
    ctx.fillRect(canvas.width - 10, 0, 10, canvas.height);
    
    // Hot corner rivets (glowing)
    [[20, 20], [canvas.width - 20, 20], [20, canvas.height - 20], [canvas.width - 20, canvas.height - 20]].forEach(([rx, ry]) => {
      ctx.fillStyle = `rgba(255,180,50,${0.5 + Math.sin(frameNow/200) * 0.3})`;
      ctx.beginPath();
      ctx.arc(rx, ry, 5, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // Door mesh on right (with light coming through)
    ctx.fillStyle = 'rgba(255,230,100,0.08)';
    ctx.fillRect(canvas.width - 50, 10, 40, canvas.height - 20);
    for (let y = 15; y < canvas.height - 15; y += 8) {
      ctx.fillStyle = `rgba(255,200,50,${0.05 + Math.sin(frameNow/400 + y/20) * 0.03})`;
      ctx.fillRect(canvas.width - 48, y, 36, 1);
    }
    
    // Humming vibration overlay
    ctx.fillStyle = `rgba(255,255,200,${0.02 + Math.sin(frameNow/100) * 0.01})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  } else if (level === 6) {
    // === THE MIXER ===
    // Stainless steel bowl interior
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    
    // Bowl base - metallic gradient
    const bowlGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(canvas.width, canvas.height) * 0.7);
    bowlGrad.addColorStop(0, '#c0c8d0');
    bowlGrad.addColorStop(0.5, '#a0aab4');
    bowlGrad.addColorStop(1, '#707a84');
    ctx.fillStyle = bowlGrad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Curved bowl reflections
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2 + frameNow / 8000;
      const rx = cx + Math.cos(angle) * canvas.width * 0.35;
      const ry = cy + Math.sin(angle) * canvas.height * 0.35;
      ctx.fillStyle = 'rgba(220,230,240,0.08)';
      ctx.beginPath();
      ctx.ellipse(rx, ry, 60, 20, angle, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // SPINNING BLADE in center!!
    const bladeAngle = frameNow / 100; // fast spin!
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(bladeAngle);
    
    // Blade glow
    const bladeGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, 80);
    bladeGlow.addColorStop(0, 'rgba(255,50,50,0.2)');
    bladeGlow.addColorStop(1, 'rgba(255,50,50,0)');
    ctx.fillStyle = bladeGlow;
    ctx.beginPath();
    ctx.arc(0, 0, 80, 0, Math.PI * 2);
    ctx.fill();
    
    // Blade arms
    for (let b = 0; b < 4; b++) {
      const a = (b / 4) * Math.PI * 2;
      ctx.fillStyle = `rgba(180,190,200,${0.7 + Math.sin(frameNow/200) * 0.1})`;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(Math.cos(a - 0.15) * 55, Math.sin(a - 0.15) * 55);
      ctx.lineTo(Math.cos(a + 0.05) * 60, Math.sin(a + 0.05) * 60);
      ctx.lineTo(Math.cos(a + 0.15) * 55, Math.sin(a + 0.15) * 55);
      ctx.closePath();
      ctx.fill();
      // Blade edge highlight
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(Math.cos(a + 0.05) * 60, Math.sin(a + 0.05) * 60);
      ctx.stroke();
    }
    
    // Center hub
    ctx.fillStyle = '#888';
    ctx.beginPath();
    ctx.arc(0, 0, 12, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#666';
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
    
    // Spinning motion lines around edges
    const time = frameNow / 500;
    for (let i = 0; i < 12; i++) {
      const a = (i / 12) * Math.PI * 2 + time;
      const r = Math.min(canvas.width, canvas.height) * 0.42;
      const sx = cx + Math.cos(a) * r;
      const sy = cy + Math.sin(a) * r;
      const ex = cx + Math.cos(a + 0.3) * (r + 15);
      const ey = cy + Math.sin(a + 0.3) * (r + 15);
      ctx.strokeStyle = `rgba(200,210,220,${0.2 + Math.sin(time + i) * 0.1})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(ex, ey);
      ctx.stroke();
    }
    
    // Bowl rim (border)
    ctx.strokeStyle = '#606a74';
    ctx.lineWidth = 12;
    ctx.strokeRect(6, 6, canvas.width - 12, canvas.height - 12);
    ctx.strokeStyle = '#8a949e';
    ctx.lineWidth = 4;
    ctx.strokeRect(12, 12, canvas.width - 24, canvas.height - 24);
    
    // Danger pulsing vignette
    const dangerPulse = Math.sin(frameNow / 400) * 0.15 + 0.15;
    const vignette = ctx.createRadialGradient(cx, cy, canvas.width * 0.2, cx, cy, canvas.width * 0.7);
    vignette.addColorStop(0, 'rgba(255,0,0,0)');
    vignette.addColorStop(1, `rgba(255,0,0,${dangerPulse})`);
    ctx.fillStyle = vignette;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  } else if (level === 7) {
    // === THE DEEP FRYER ===
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    
    // Hot oil base - deep golden yellow
    ctx.fillStyle = '#c8920a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Oil gradient - darker at edges (deep fryer walls)
    const oilGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(canvas.width, canvas.height) * 0.6);
    oilGrad.addColorStop(0, 'rgba(220,170,30,0.6)');
    oilGrad.addColorStop(0.7, 'rgba(180,120,10,0.3)');
    oilGrad.addColorStop(1, 'rgba(100,60,0,0.5)');
    ctx.fillStyle = oilGrad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Bubbling oil - animated bubbles rising
    for (let i = 0; i < 30; i++) {
      const bx = ((i * 173 + frameNow / 10) % canvas.width);
      const byBase = canvas.height - ((frameNow / (3 + i % 5) + i * 200) % canvas.height);
      const bSize = 4 + (i % 5) * 2;
      const alpha = 0.15 + Math.sin(frameNow / 300 + i) * 0.1;
      
      // Bubble
      ctx.fillStyle = `rgba(255,220,80,${alpha})`;
      ctx.beginPath();
      ctx.arc(bx, byBase, bSize, 0, Math.PI * 2);
      ctx.fill();
      
      // Bubble highlight
      ctx.fillStyle = `rgba(255,240,150,${alpha * 0.6})`;
      ctx.beginPath();
      ctx.arc(bx - bSize * 0.3, byBase - bSize * 0.3, bSize * 0.4, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Oil surface shimmer
    for (let x = 0; x < canvas.width; x += 40) {
      const shimmerY = Math.sin(frameNow / 600 + x / 50) * 3;
      ctx.fillStyle = 'rgba(255,230,100,0.08)';
      ctx.fillRect(x, shimmerY, 35, canvas.height);
    }
    
    // Sizzle sparks popping up
    for (let i = 0; i < 8; i++) {
      const t = frameNow / 200 + i * 50;
      const sx = (Math.sin(t * 0.7 + i * 3) * 0.5 + 0.5) * canvas.width;
      const sy = (Math.cos(t * 0.5 + i * 2) * 0.5 + 0.5) * canvas.height;
      const sparkAlpha = Math.max(0, Math.sin(t) * 0.6);
      if (sparkAlpha > 0.1) {
        ctx.fillStyle = `rgba(255,255,200,${sparkAlpha})`;
        ctx.beginPath();
        ctx.arc(sx, sy, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // Fryer walls - dark metal border
    ctx.fillStyle = '#4a3a20';
    ctx.fillRect(0, 0, canvas.width, 14);
    ctx.fillRect(0, canvas.height - 14, canvas.width, 14);
    ctx.fillRect(0, 0, 14, canvas.height);
    ctx.fillRect(canvas.width - 14, 0, 14, canvas.height);
    
    // Inner wall rim
    ctx.strokeStyle = '#6a5a30';
    ctx.lineWidth = 3;
    ctx.strokeRect(16, 16, canvas.width - 32, canvas.height - 32);
    
    // Heat haze overlay
    const haze = Math.sin(frameNow / 200) * 0.03 + 0.03;
    ctx.fillStyle = `rgba(255,200,50,${haze})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Danger pulsing - orange for fryer
    const fryPulse = Math.sin(frameNow / 350) * 0.1 + 0.1;
    const fryVignette = ctx.createRadialGradient(cx, cy, canvas.width * 0.2, cx, cy, canvas.width * 0.7);
    fryVignette.addColorStop(0, 'rgba(255,100,0,0)');
    fryVignette.addColorStop(1, `rgba(255,80,0,${fryPulse})`);
    ctx.fillStyle = fryVignette;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  } else if (level === 8) {
    // === THE DOUGH COUNTER ===
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    
    // Wooden counter surface
    ctx.fillStyle = '#c49a6c';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Wood grain lines
    ctx.strokeStyle = 'rgba(139,90,43,0.3)';
    ctx.lineWidth = 1;
    for (let y = 0; y < canvas.height; y += 12) {
      ctx.beginPath();
      ctx.moveTo(0, y + Math.sin(y / 30) * 3);
      for (let x = 0; x < canvas.width; x += 20) {
        ctx.lineTo(x, y + Math.sin((y + x) / 40) * 4);
      }
      ctx.stroke();
    }
    
    // Big flour circle in center (rolled dough area)
    const flourGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.min(canvas.width, canvas.height) * 0.4);
    flourGrad.addColorStop(0, 'rgba(255,250,240,0.6)');
    flourGrad.addColorStop(0.6, 'rgba(255,245,230,0.3)');
    flourGrad.addColorStop(1, 'rgba(255,240,220,0)');
    ctx.fillStyle = flourGrad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Scattered flour spots
    ctx.fillStyle = 'rgba(255,250,240,0.25)';
    for (let i = 0; i < 20; i++) {
      const fx = Math.sin(i * 7.3) * canvas.width * 0.45 + cx;
      const fy = Math.cos(i * 5.1) * canvas.height * 0.4 + cy;
      ctx.beginPath();
      ctx.arc(fx, fy, 15 + Math.sin(i * 3) * 10, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Dough blob ‚Äî flat circle
    ctx.fillStyle = 'rgba(230,210,170,0.4)';
    ctx.strokeStyle = 'rgba(180,150,100,0.3)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(cx, cy, canvas.width * 0.2, canvas.height * 0.18, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    
    // Rolling marks across the dough
    ctx.strokeStyle = 'rgba(180,150,100,0.2)';
    ctx.lineWidth = 3;
    for (let r = -3; r <= 3; r++) {
      ctx.beginPath();
      ctx.moveTo(cx - canvas.width * 0.18, cy + r * 20);
      ctx.lineTo(cx + canvas.width * 0.18, cy + r * 20);
      ctx.stroke();
    }
    
    // Counter edges
    ctx.fillStyle = '#8b5e3c';
    ctx.fillRect(0, 0, canvas.width, 8);
    ctx.fillRect(0, canvas.height - 8, canvas.width, 8);
    ctx.fillRect(0, 0, 8, canvas.height);
    ctx.fillRect(canvas.width - 8, 0, 8, canvas.height);
  } else if (level === 9) {
    // === THE STOVETOP RETURNS ===
    // Dark hot stovetop
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Subtle texture
    for (let x = 0; x < canvas.width; x += 3) {
      for (let y = 0; y < canvas.height; y += 3) {
        if (Math.random() < 0.08) {
          ctx.fillStyle = `rgba(255,100,0,${Math.random() * 0.03})`;
          ctx.fillRect(x, y, 2, 2);
        }
      }
    }

    // Four burners - ALL ON
    const burnerPositions9 = [
      [canvas.width * 0.25, canvas.height * 0.3],
      [canvas.width * 0.75, canvas.height * 0.3],
      [canvas.width * 0.25, canvas.height * 0.7],
      [canvas.width * 0.75, canvas.height * 0.7],
    ];
    // Store for hazard detection
    window._burnerZones = burnerPositions9.map(([bx, by]) => ({
      x: bx, y: by, radius: Math.min(canvas.width, canvas.height) * 0.15
    }));

    burnerPositions9.forEach(([bx, by]) => {
      const radius = Math.min(canvas.width, canvas.height) * 0.15;
      // Burner ring
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(bx, by, radius, 0, Math.PI * 2);
      ctx.stroke();
      // Inner ring
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(bx, by, radius * 0.65, 0, Math.PI * 2);
      ctx.stroke();
      // Center
      ctx.fillStyle = '#383838';
      ctx.beginPath();
      ctx.arc(bx, by, radius * 0.3, 0, Math.PI * 2);
      ctx.fill();

      // ALL burners glowing red/orange
      const flicker = Math.sin(frameNow / 200 + bx) * 30;
      ctx.strokeStyle = `rgba(255,${80 + flicker},0,0.8)`;
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(bx, by, radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.strokeStyle = `rgba(255,${60 + Math.sin(frameNow/150 + by)*20},0,0.5)`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(bx, by, radius * 0.65, 0, Math.PI * 2);
      ctx.stroke();
      // Glow
      const grad = ctx.createRadialGradient(bx, by, 0, bx, by, radius * 1.3);
      grad.addColorStop(0, 'rgba(255,60,0,0.2)');
      grad.addColorStop(1, 'rgba(255,60,0,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(bx, by, radius * 1.3, 0, Math.PI * 2);
      ctx.fill();

      // Grate lines
      ctx.strokeStyle = '#505050';
      ctx.lineWidth = 4;
      for (let g = -1; g <= 1; g += 2) {
        ctx.beginPath();
        ctx.moveTo(bx - radius, by + g * radius * 0.3);
        ctx.lineTo(bx + radius, by + g * radius * 0.3);
        ctx.stroke();
      }
    });

    // Heat haze overlay
    ctx.fillStyle = 'rgba(255,50,0,0.03)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
}

// ============ SOUND SYSTEM (Web Audio) ============
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function ensureAudio() {
  if (!audioCtx) audioCtx = new AudioCtx();
}

function playSound(type) {
  try {
    ensureAudio();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    const t = audioCtx.currentTime;

    if (type === 'hit') {
      osc.type = 'square';
      osc.frequency.setValueAtTime(200, t);
      osc.frequency.exponentialRampToValueAtTime(80, t + 0.1);
      gain.gain.setValueAtTime(0.15, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
      osc.start(t); osc.stop(t + 0.1);
    } else if (type === 'playerHit') {
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(300, t);
      osc.frequency.exponentialRampToValueAtTime(50, t + 0.2);
      gain.gain.setValueAtTime(0.2, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
      osc.start(t); osc.stop(t + 0.2);
    } else if (type === 'kill') {
      osc.type = 'square';
      osc.frequency.setValueAtTime(400, t);
      osc.frequency.exponentialRampToValueAtTime(800, t + 0.15);
      gain.gain.setValueAtTime(0.12, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
      osc.start(t); osc.stop(t + 0.15);
    } else if (type === 'recruit') {
      osc.type = 'sine';
      osc.frequency.setValueAtTime(500, t);
      osc.frequency.setValueAtTime(700, t + 0.1);
      osc.frequency.setValueAtTime(900, t + 0.2);
      gain.gain.setValueAtTime(0.12, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
      osc.start(t); osc.stop(t + 0.3);
    } else if (type === 'heal') {
      osc.type = 'sine';
      osc.frequency.setValueAtTime(600, t);
      osc.frequency.exponentialRampToValueAtTime(1200, t + 0.2);
      gain.gain.setValueAtTime(0.1, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
      osc.start(t); osc.stop(t + 0.25);
    } else if (type === 'levelUp') {
      osc.type = 'sine';
      [400,500,600,800].forEach((f, i) => {
        osc.frequency.setValueAtTime(f, t + i * 0.12);
      });
      gain.gain.setValueAtTime(0.15, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
      osc.start(t); osc.stop(t + 0.5);
    }
  } catch(e) {}
}

// ============ GAME LOGIC ============
function dist(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}

function knockback(entity, fromX, fromY, force) {
  const dx = entity.x - fromX;
  const dy = entity.y - fromY;
  const d = Math.hypot(dx, dy) || 1;
  entity.kbx = (entity.kbx || 0) + (dx / d) * force;
  entity.kby = (entity.kby || 0) + (dy / d) * force;
}

// Health drops

function spawnHealthDrop(x, y) {
  healthDrops.push({
    x, y,
    size: 20,
    life: 600, // 10 seconds
    bobOffset: Math.random() * Math.PI * 2,
  });
}

function updatePlayer(dt) {
  if (!player) return;

  let dx = 0, dy = 0;
  if (keys['arrowleft'] || keys['a']) dx -= 1;
  if (keys['arrowright'] || keys['d']) dx += 1;
  if (keys['arrowup'] || keys['w']) dy -= 1;
  if (keys['arrowdown'] || keys['s']) dy += 1;

  if (dx !== 0 || dy !== 0) {
    const len = Math.hypot(dx, dy);
    dx /= len; dy /= len;
    player.x += dx * player.speed;
    player.y += dy * player.speed;
    if (dx !== 0) player.facing = dx > 0 ? 1 : -1;
  }

  // Apply knockback
  if (player.kbx || player.kby) {
    player.x += player.kbx || 0;
    player.y += player.kby || 0;
    player.kbx = (player.kbx || 0) * 0.7;
    player.kby = (player.kby || 0) * 0.7;
    if (Math.abs(player.kbx) < 0.1) player.kbx = 0;
    if (Math.abs(player.kby) < 0.1) player.kby = 0;
  }


    // Burner hazard damage (level 9)
    if (currentLevel === 9 && window._burnerZones) {
      if (!player._burnerCooldown) player._burnerCooldown = 0;
      if (player._burnerCooldown > 0) player._burnerCooldown--;
      if (player._burnerCooldown <= 0) {
        for (const zone of window._burnerZones) {
          const bd = Math.hypot(player.x - zone.x, player.y - zone.y);
          if (bd < zone.radius) {
            player.hp -= 2;
            player._burnerCooldown = 30;
            // Fire particle feedback
            for (let p = 0; p < 3; p++) {
              particles.push({
                x: player.x + (Math.random()-0.5)*20,
                y: player.y + (Math.random()-0.5)*20,
                vx: (Math.random()-0.5)*3,
                vy: -Math.random()*3,
                life: 20,
                color: Math.random() > 0.5 ? '#ff4400' : '#ffaa00',
                size: 4
              });
            }
            break;
          }
        }
      }
    }
  // Clamp to arena
  player.x = Math.max(40, Math.min(canvas.width - 40, player.x));
  player.y = Math.max(40, Math.min(canvas.height - 40, player.y));

  // Attack
  if (player.attackCooldown > 0) player.attackCooldown--;

  if (keys[' '] && player.attackCooldown === 0) {
    player.attackCooldown = 18;
    playSound('hit');
    let hitAny = false;
    // Damage enemies in range ‚Äî directional (wider arc in facing direction)
    enemies.forEach(e => {
      const d = dist(player, e);
      if (d < player.attackRange + e.size) {
        const dirToEnemy = e.x - player.x;
        // Hit enemies on the side you're facing more easily, but still hit close ones on either side
        if (d < 45 || (player.facing > 0 && dirToEnemy > -20) || (player.facing < 0 && dirToEnemy < 20)) {
          e.hp -= player.damage;
          e.hit = 10;
          knockback(e, player.x, player.y, 8);
          spawnParticles(e.x, e.y, '#ffaa00', 5);
          createFloatingText(e.x, e.y - 30, `-${player.damage}`, '#ff4444');
          shakeTimer = 5;
          hitAny = true;
        }
      }
    });
  }

  // Recruit ally
  if (keys['e']) {
    for (let i = foodPickups.length - 1; i >= 0; i--) {
      if (dist(player, foodPickups[i]) < 60) {
        recruitAlly(foodPickups[i]);
        foodPickups.splice(i, 1);
        score += 100;
        playSound('recruit');
      }
    }
  }

  // Pick up health drops and handle timeout
  for (let i = healthDrops.length - 1; i >= 0; i--) {
    const hd = healthDrops[i];
    hd.life--;
    if (dist(player, hd) < 40 && player.hp < player.maxHp) {
      const healAmt = 25;
      player.hp = Math.min(player.maxHp, player.hp + healAmt);
      createFloatingText(hd.x, hd.y - 20, `+${healAmt} HP`, '#44ff44');
      spawnParticles(hd.x, hd.y, '#44ff44', 10);
      playSound('heal');
      healthDrops.splice(i, 1);
    } else if (hd.life <= 0) {
      healthDrops.splice(i, 1);
    }
  }

  // Invincibility timer
  if (player.invincible > 0) player.invincible--;

  // Update HUD
  document.getElementById('health-bar').style.width = Math.max(0, (player.hp / player.maxHp) * 100) + '%';
  document.getElementById('score-display').textContent = score;
  document.getElementById('enemy-count').textContent = enemies.length + waveQueue.length;
}

function updateEnemies() {
  const newEnemies = []; // collect pizza slices to add after iteration
  for (let ei = enemies.length - 1; ei >= 0; ei--) {
    const e = enemies[ei];
    if (e.hit > 0) e.hit--;
    if (e.attackCooldown > 0) e.attackCooldown--;

    // Apply knockback
    if (e.kbx || e.kby) {
      e.x += e.kbx || 0;
      e.y += e.kby || 0;
      e.kbx = (e.kbx || 0) * 0.7;
      e.kby = (e.kby || 0) * 0.7;
      if (Math.abs(e.kbx) < 0.1) e.kbx = 0;
      if (Math.abs(e.kby) < 0.1) e.kby = 0;
      continue; // skip AI while being knocked back
    }

    // === ENEMY-SPECIFIC BEHAVIOR ===
    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const d = Math.hypot(dx, dy);

    if (e.type === 'knife') {
      // Knives: dash attack ‚Äî charge fast when close-ish
      if (!e.dashCooldown) e.dashCooldown = 0;
      if (e.dashCooldown > 0) e.dashCooldown--;
      if (d < 200 && d > 60 && e.dashCooldown === 0) {
        // DASH toward player
        e.x += (dx / d) * e.speed * 4;
        e.y += (dy / d) * e.speed * 4;
        e.dashCooldown = 120; // 2 second cooldown
      } else if (d > e.size + 20) {
        e.x += (dx / d) * e.speed;
        e.y += (dy / d) * e.speed;
      }
    } else if (e.type === 'spoon') {
      // Spoons: circle around player, attack in groups
      const circleAngle = Math.atan2(dy, dx) + Math.PI + Math.sin(frameNow / 800 + e.bobOffset) * 1.5;
      const targetDist = 80;
      const tx = player.x + Math.cos(circleAngle) * targetDist;
      const ty = player.y + Math.sin(circleAngle) * targetDist;
      const tdx = tx - e.x;
      const tdy = ty - e.y;
      const td = Math.hypot(tdx, tdy);
      if (td > 5) {
        e.x += (tdx / td) * e.speed * 1.2;
        e.y += (tdy / td) * e.speed * 1.2;
      }
    } else if (e.type === 'whisk' || e.type === 'mixer' || e.type === 'cleaver' || e.type === 'fryer' || e.type === 'pizza' || e.type === 'rolling_pin' || e.type === 'frying_pan') {
      // Bosses: slower but periodic special attack
      if (!e.specialTimer) e.specialTimer = 180;
      e.specialTimer--;
      
      if (d > e.size + 30) {
        e.x += (dx / d) * e.speed;
        e.y += (dy / d) * e.speed;
      }
      
      // Boss special: spawn a burst ring of particles as AOE warning then damage
      if (e.specialTimer <= 0) {
        e.specialTimer = 200 + Math.random() * 100;
        // AOE attack
        spawnParticles(e.x, e.y, '#ff4444', 30);
        shakeTimer = 12;
        // Damage player if in range
        if (d < 120) {
          const bossDmg = Math.floor(e.damage * 1.5);
          player.hp -= bossDmg;
          player.invincible = 40;
          knockback(player, e.x, e.y, 15);
          flashDamage();
          createFloatingText(player.x, player.y - 40, `-${bossDmg}!!`, '#ff0000');
          playSound('playerHit');
        }
        // Also damage nearby allies
        allies.forEach(a => {
          if (dist(a, e) < 120) {
            a.hp -= e.damage;
            a.hit = 10;
            knockback(a, e.x, e.y, 10);
          }
        });
      }
      
      // Boss warning ring when special is about to fire
      if (e.specialTimer < 40) {
        e.warningRing = true;
      } else {
        e.warningRing = false;
      }
    } else {
      // Default (forks): simple chase with wobble
      if (d > e.size + 20) {
        const wobble = Math.sin(frameNow / 500 + e.bobOffset) * 0.5;
        e.x += (dx / d) * e.speed + wobble;
        e.y += (dy / d) * e.speed;
      }
    }

    // Clamp to arena
    e.x = Math.max(20, Math.min(canvas.width - 20, e.x));
    e.y = Math.max(20, Math.min(canvas.height - 20, e.y));

    // Normal melee attack player
    if (d < e.size + 35 && e.attackCooldown === 0 && player.invincible === 0) {
      player.hp -= e.damage;
      player.invincible = 30;
      e.attackCooldown = 60;
      knockback(player, e.x, e.y, 10);
      flashDamage();
      shakeTimer = 8;
      createFloatingText(player.x, player.y - 40, `-${e.damage}`, '#ff0000');
      spawnParticles(player.x, player.y, '#ff4444', 8);
      playSound('playerHit');
    }

    // Also attack nearby allies
    allies.forEach(a => {
      if (dist(e, a) < e.size + 25 && e.attackCooldown === 0) {
        a.hp -= Math.floor(e.damage * 0.5);
        a.hit = 10;
        knockback(a, e.x, e.y, 6);
        e.attackCooldown = 60;
      }
    });

    // Check death
    if (e.hp <= 0) {
      score += e.score;
      spawnParticles(e.x, e.y, '#ffdd00', 20);
      createFloatingText(e.x, e.y, `+${e.score}`, '#ffdd00');
      playSound('kill');
      
      // PIZZA SPLIT: spawns 6 pizza slices when destroyed!
      if (e.type === 'pizza' && !e.noSplit) {
        createFloatingText(e.x, e.y - 40, 'PIZZA SPLITS!', '#ff6600');
        spawnParticles(e.x, e.y, '#ff8800', 30);
        const sliceDef = ENEMY_DEFS['pizza_slice'];
        for (let s = 0; s < 6; s++) {
          const angle = (s / 6) * Math.PI * 2;
          const dist = 60;
          newEnemies.push({
            x: e.x + Math.cos(angle) * dist,
            y: e.y + Math.sin(angle) * dist,
            type: 'pizza_slice',
            emoji: sliceDef.emoji,
            hp: sliceDef.hp,
            maxHp: sliceDef.hp,
            speed: sliceDef.speed + Math.random() * 0.3,
            damage: sliceDef.damage,
            size: sliceDef.size,
            score: sliceDef.score,
            attackCooldown: 60,
            hit: 0,
            kbx: Math.cos(angle) * 12,
            kby: Math.sin(angle) * 12,
            angle: angle,
            bobOffset: Math.random() * Math.PI * 2,
          });
        }
      }
      
      // PIZZA REFORM: if all slices are dead, check if pizza should reform
      // (Pizza gets one split per life ‚Äî slices don't re-split)
      
      // 30% chance to drop health
      if (Math.random() < 0.3) {
        spawnHealthDrop(e.x, e.y);
      }
      enemies.splice(ei, 1);
    }
  }
  // Add pizza slices after iteration so they aren't processed this frame
  if (newEnemies.length > 0) {
    enemies.push(...newEnemies);
  }
}

function updateAllies() {
  for (let ai = allies.length - 1; ai >= 0; ai--) {
    const a = allies[ai];
    if (a.hit > 0) a.hit--;
    if (a.attackCooldown > 0) a.attackCooldown--;

    // Allies slowly wilt ‚Äî lose 1 HP every 2 seconds
    a._wiltTimer = (a._wiltTimer || 0) + 1;
    if (a._wiltTimer >= 120) {
      a._wiltTimer = 0;
      a.hp -= 1;
    }

    // Apply knockback
    if (a.kbx || a.kby) {
      a.x += a.kbx || 0;
      a.y += a.kby || 0;
      a.kbx = (a.kbx || 0) * 0.7;
      a.kby = (a.kby || 0) * 0.7;
      if (Math.abs(a.kbx) < 0.1) a.kbx = 0;
      if (Math.abs(a.kby) < 0.1) a.kby = 0;
    }

    // Find nearest enemy
    let nearest = null;
    let nearDist = Infinity;
    enemies.forEach(e => {
      const d = dist(a, e);
      if (d < nearDist) { nearest = e; nearDist = d; }
    });

    if (nearest) {
      // Move toward enemy (reuse nearDist from search above)
      const dx = nearest.x - a.x;
      const dy = nearest.y - a.y;

      if (nearDist > a.size + 20) {
        a.x += (dx / nearDist) * a.speed;
        a.y += (dy / nearDist) * a.speed;
      }

      // Attack
      if (nearDist < a.size + 35 && a.attackCooldown === 0) {
        nearest.hp -= a.damage;
        nearest.hit = 10;
        knockback(nearest, a.x, a.y, 5);
        a.attackCooldown = 40;
        spawnParticles(nearest.x, nearest.y, '#88ff88', 3);
        createFloatingText(nearest.x, nearest.y - 20, `-${a.damage}`, '#88ff88');
      }
    } else {
      // Follow player if no enemies
      const dx = player.x - a.x;
      const dy = player.y - a.y;
      const d = Math.hypot(dx, dy);
      if (d > 60) {
        a.x += (dx / d) * a.speed * 0.7;
        a.y += (dy / d) * a.speed * 0.7;
      }
    }

    // Check ally death
    if (a.hp <= 0) {
      spawnParticles(a.x, a.y, '#4488ff', 15);
      createFloatingText(a.x, a.y, `${a.emoji} down!`, '#ff6666');
      allies.splice(ai, 1);
      continue;
    }

    // Clamp
    a.x = Math.max(20, Math.min(canvas.width - 20, a.x));
    a.y = Math.max(20, Math.min(canvas.height - 20, a.y));
  }

  // Update ally icons in HUD
  const iconsDiv = document.getElementById('ally-icons');
  iconsDiv.innerHTML = allies.map(a => `<span class="ally-icon">${a.emoji}</span>`).join('');
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 0.03;
    p.vx *= 0.95;
    p.vy *= 0.95;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

// ============ GAME LOOP ============
function gameLoop() {
  requestAnimationFrame(gameLoop);
  frameNow = Date.now();

  if (gameState !== 'playing') return;

  // Screen shake
  ctx.save();
  if (shakeTimer > 0) {
    ctx.translate(
      (Math.random() - 0.5) * shakeTimer * 2,
      (Math.random() - 0.5) * shakeTimer * 2
    );
    shakeTimer--;
  }

  drawBackground(currentLevel);

  // Draw food pickups
  foodPickups.forEach(fp => {
    fp.glow = (fp.glow + 0.05) % (Math.PI * 2);
    const glow = Math.sin(fp.glow) * 0.3 + 0.7;
    ctx.save();
    ctx.translate(fp.x, fp.y);
    const bob = Math.sin(frameNow / 400 + fp.bobOffset) * 5;
    const ringR = fp.strong ? 30 : 25;

    // Blue filled circle behind
    ctx.fillStyle = fp.strong ? `rgba(40,100,255,${glow * 0.25})` : `rgba(40,100,220,0.15)`;
    ctx.beginPath();
    ctx.arc(0, bob, ringR, 0, Math.PI * 2);
    ctx.fill();

    // Blue glow ring
    ctx.strokeStyle = fp.strong ? `rgba(80,160,255,${glow * 0.9})` : `rgba(60,140,255,${glow * 0.7})`;
    ctx.lineWidth = fp.strong ? 4 : 3;
    ctx.beginPath();
    ctx.arc(0, bob, ringR, 0, Math.PI * 2);
    ctx.stroke();

    // Second outer ring for strong food
    if (fp.strong) {
      ctx.strokeStyle = `rgba(100,180,255,${glow * 0.4})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, bob, ringR + 8, 0, Math.PI * 2);
      ctx.stroke();
    }

    // "Press E" hint
    if (player && dist(player, fp) < 80) {
      ctx.font = 'bold 14px Quicksand';
      ctx.fillStyle = '#88ccff';
      ctx.textAlign = 'center';
      ctx.fillText('Press E', 0, bob - 38);
    }

    ctx.font = `${fp.size}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(fp.emoji, 0, bob);

    // Star for strong
    if (fp.strong) {
      ctx.font = '16px serif';
      ctx.fillText('‚≠ê', ringR * 0.8, -ringR * 0.8 + bob);
    }

    ctx.restore();
  });

  // Update and draw
  updatePlayer();
  updateEnemies();
  
  // Pizza reform check: if there were pizza slices but now they're all dead,
  // and there's no pizza boss, reform it with half HP
  if (currentLevel === 8) {
    const hasSlices = enemies.some(e => e.type === 'pizza_slice');
    const hasPizza = enemies.some(e => e.type === 'pizza');
    const hadPizzaSplit = !hasPizza && !hasSlices && (window._pizzaWasSplit || false);
    
    // Track if pizza has split
    if (enemies.some(e => e.type === 'pizza_slice')) {
      window._pizzaWasSplit = true;
    }
    
    // Reform!
    if (window._pizzaWasSplit && !hasSlices && !hasPizza && !window._pizzaReformed) {
      window._pizzaReformed = true;
      const def = ENEMY_DEFS['pizza'];
      const cx = canvas.width / 2, cy = canvas.height / 2;
      enemies.push({
        x: cx, y: cy,
        type: 'pizza',
        emoji: def.emoji,
        hp: Math.floor(def.hp * 0.5),
        maxHp: Math.floor(def.hp * 0.5),
        speed: def.speed * 1.3,
        damage: def.damage,
        size: def.size,
        score: def.score,
        attackCooldown: 0,
        hit: 0,
        kbx: 0, kby: 0,
        angle: 0,
        bobOffset: Math.random() * Math.PI * 2,
        noSplit: true, // won't split again
      });
      createFloatingText(cx, cy - 40, 'PIZZA REFORMS!', '#ff0000');
      spawnParticles(cx, cy, '#ff4400', 30);
      shakeTimer = 15;
      playSound('playerHit');
    }
  }
  updateAllies();
  updateParticles();

  // Random food spawns
  foodSpawnTimer++;
  if (foodSpawnTimer >= 180 && enemies.length > 0) { // every ~3 seconds
    foodSpawnTimer = 0;
    spawnRandomFood();
  }

  // Draw health drops
  healthDrops.forEach(hd => {
    ctx.save();
    ctx.translate(hd.x, hd.y);
    const bob = Math.sin(frameNow / 350 + hd.bobOffset) * 4;
    const blink = hd.life < 120 ? (Math.floor(frameNow / 100) % 2 === 0 ? 0.4 : 1) : 1;
    ctx.globalAlpha = blink;
    // Green glow
    ctx.fillStyle = 'rgba(50,200,50,0.3)';
    ctx.beginPath();
    ctx.arc(0, bob, 18, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(50,255,50,0.6)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, bob, 18, 0, Math.PI * 2);
    ctx.stroke();
    // Heart emoji
    ctx.font = '20px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('üíö', 0, bob);
    ctx.globalAlpha = 1;
    ctx.restore();
  });

  // Draw allies
  allies.forEach(a => drawEntity(a, a.emoji, a.size, true, true));

  // Draw enemies
  enemies.forEach(e => {
    // Boss warning ring before special attack
    if (e.warningRing) {
      const pulse = Math.sin(frameNow / 80) * 0.3 + 0.5;
      ctx.strokeStyle = `rgba(255,50,50,${pulse})`;
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 4]);
      ctx.beginPath();
      ctx.arc(e.x, e.y, 120, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
    }
    drawEntity(e, e.emoji, e.size * 1.4, true, false);
  });

  // Draw player
  if (player) drawPotato(player);

  drawParticles();

  ctx.restore();

  // Wave spawning ‚Äî spawn remaining enemies gradually
  if (waveQueue.length > 0) {
    waveTimer++;
    if (waveTimer >= 90) { // every 1.5 seconds
      waveTimer = 0;
      // Spawn 2-3 from queue at a time
      const batchSize = Math.min(2 + Math.floor(Math.random() * 2), waveQueue.length);
      for (let i = 0; i < batchSize; i++) {
        enemies.push(waveQueue.shift());
      }
    }
  }

  // Check level complete
  if (enemies.length === 0 && waveQueue.length === 0) {
    if (currentLevel < 9) {
      currentLevel++;
      playSound('levelUp');
      showLevelIntro();
    } else {
      playSound('levelUp');
      showWinScreen();
    }
  }

  // Check game over
  if (player && player.hp <= 0) {
    showGameOver();
  }
}

// ============ SCREEN MANAGEMENT ============
function hideAllScreens() {
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('level-screen').style.display = 'none';
  document.getElementById('game-over-screen').style.display = 'none';
  document.getElementById('win-screen').style.display = 'none';
}

function showLevelIntro() {
  gameState = 'levelIntro';
  hideAllScreens();
  const lvl = LEVELS[currentLevel - 1];
  document.getElementById('level-screen').style.display = 'flex';
  document.getElementById('level-title').textContent = `Level ${currentLevel}: ${lvl.name}`;
  document.getElementById('level-desc').textContent = lvl.desc;

  // Show enemy emojis
  const preview = document.getElementById('enemy-preview');
  let emojis = [];
  lvl.enemies.forEach(g => {
    const def = ENEMY_DEFS[g.type];
    for (let i = 0; i < Math.min(g.count, 3); i++) emojis.push(def.emoji);
  });
  preview.innerHTML = emojis.map(e => `<span>${e}</span>`).join('');

  document.getElementById('level-display').textContent = `Level ${currentLevel}`;
}

function startLevel() {
  gameState = 'playing';
  hideAllScreens();
  document.getElementById('hud').style.display = 'flex';

  if (!player) {
    player = createPlayer();
    allies = [];
    score = 0;
  } else {
    // Heal up between levels
    player.hp = Math.min(player.maxHp, player.hp + 50);
  }

  enemies = [];
  foodPickups = [];
  particles = [];
  healthDrops = [];
  waveQueue = [];
  waveTimer = 0;
  foodSpawnTimer = 0;
  window._pizzaWasSplit = false;
  window._pizzaReformed = false;
  spawnEnemies(currentLevel);
  spawnFoodPickup(currentLevel);
}

function showGameOver() {
  gameState = 'gameOver';
  hideAllScreens();
  document.getElementById('game-over-screen').style.display = 'flex';
  document.getElementById('final-score').textContent = score;
  document.getElementById('hud').style.display = 'none';
  if (currentLevel === 7) {
    document.getElementById('gameover-emoji').textContent = 'üçü';
    document.getElementById('gameover-title').textContent = "YOU'VE BEEN TURNED INTO FRENCH FRIES!";
  } else if (currentLevel === 8) {
    document.getElementById('gameover-emoji').textContent = 'ü´ì';
    document.getElementById('gameover-title').textContent = "YOU'VE BEEN ROLLED INTO FLATBREAD!";
  } else if (currentLevel === 9) {
    document.getElementById('gameover-emoji').textContent = 'üî•';
    document.getElementById('gameover-title').textContent = "YOU'VE BEEN BURNT!";
  } else {
    document.getElementById('gameover-emoji').textContent = 'üòµ';
    document.getElementById('gameover-title').textContent = 'MASHED POTATO!';
  }
}

function showWinScreen() {
  gameState = 'win';
  hideAllScreens();
  document.getElementById('win-screen').style.display = 'flex';
  document.getElementById('win-score').textContent = score;
  document.getElementById('hud').style.display = 'none';
}

function resetGame() {
  currentLevel = (typeof TEST_START_LEVEL === 'number') ? TEST_START_LEVEL : 1;
  score = 0;
  player = null;
  enemies = [];
  allies = [];
  particles = [];
  foodPickups = [];
  projectiles = [];
  healthDrops = [];
  waveQueue = [];
  waveTimer = 0;
}

// ============ BUTTON HANDLERS ============
document.getElementById('start-btn').addEventListener('click', () => {
  ensureAudio();
  resetGame();
  showLevelIntro();
});

document.getElementById('go-btn').addEventListener('click', () => {
  startLevel();
});

document.getElementById('retry-btn').addEventListener('click', () => {
  resetGame();
  showLevelIntro();
});

document.getElementById('replay-btn').addEventListener('click', () => {
  resetGame();
  showLevelIntro();
});

// Start the loop
gameLoop();
</script>
</body>
</html>